# Java基础学习

学习链接：https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click

## **数据结构**

### 二叉查找树（又称二叉排序树或者二叉搜索树）

#### 特点

1. 每个节点上最多有两个子节点
2. 任意节点的左子树上的值都小于当前节点
3. 任意右子树上的值都大于当前节点

![image-20240217154203250](image\image-20240217154203250.png)

#### 添加节点（规则）

小的存左边，大的存右边，一样的不存

#### 二叉树的遍历

1. ##### 前序遍历

   从根节点开始，然后按照当前节点，左子节点，右子节点的顺序遍历

   ![image-20240217155114693](image\image-20240217155114693.png)

2. ##### 中序遍历

   从最左边节点开始，然后按照左子节点，当前节点，右子节点的顺序遍历

   ![image-20240217155445165](image\image-20240217155445165.png)

3. ##### 后序遍历

   从最左边的子节点开始，然后按照左子节点，右子节点，当前节点的顺组遍历

   ![image-20240217155837781](image\image-20240217155837781.png)

4. ##### 层序遍历

   从根节点开始一层一层的遍历

   ![image-20240217155951075](image\image-20240217155951075.png)

#### 8个专业名词

![image-20240217160227329](image\image-20240217160227329.png)

### 平衡二叉树

规则：任意节点左右子树的高度差不超过1

![image-20240217161011812](image\image-20240217161011812.png)

![image-20240217161050705](image\image-20240217161050705.png)

#### 平衡二叉树的旋转机制

确定节点：从添加的节点开始，不断的往父节点找不平衡的节点

1. ##### 左旋

   ###### 简单情况：

   以不平衡的点作为支点，

   把指点左旋降级，变成左子节点，

   晋升原来的右子节点。

   ![image-20240217235638310](image\image-20240217235638310.png)

   ![image-20240217235723804](image\image-20240217235723804.png)

   ###### 复杂情况：

   以不平衡的节点作为支点，

   将根节点的右侧往左拉，

   原先的右子节点变为新的父节点，并把多余的左子节点出让，给已降级的根节点当右子节点。

   ![image-20240217234814974](image\image-20240217234814974.png)

   ![image-20240217234846071](image\image-20240217234846071.png)

2. 右旋
   情况与左旋类似，在左旋的情况下，左变右，右变左，即为右旋的情况

#### 使用旋转的四种情况

1. 左左（当根节点左子树的左子树有节点插入，导致二叉树不平衡）

   一次右旋

2. 左右（当根节点左子树的右子树右节点插入，导致二叉树不平衡）

   局部左旋，再整体右旋

3. 右右（当根节点右子树的右子树有节点插入，导致二叉树不平衡）

   一次左旋

4. 右左（当根节点右子树的左子树右节点插入，导致二叉树不平衡）
   局部右旋，再整体左旋 

### 红黑树

红黑树的每个节点可以是**红或者黑**；红黑树**不是高度平衡**的，它的平衡时通过“**红黑规则**”进行实现的。

#### 红黑规则

1. 每个节点是红色或者黑色的
2. 根节点必须是黑色的
3. 叶节点是黑色的
4. 两个红色节点不能相连
5. 任意节点到其所有后代叶节点的简单路径上，黑色节点的数量相同

#### 红黑树添加节点的规则

添加节点时，默认颜色是**红色的**（效率高）

![image-20240218172204506](image\image-20240218172204506.png)

## Set系列集合

#### 特点

1. 无序，不重复，无索引
2. set集合的方法基本上和Collection的API一致

#### set集合的实现类特点

HashSet：无序、不重复、无索引

LinkedHashSet：有序、不重复、无索引

TreeSet：可排序、不重复、无索引

### HashSet的底层原理

1. 创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table

2. 根据元素恶的哈希值跟数组的长度及选出应存入的位置

3. 判断当前位置是否为null，如果是null直接存入

4. 如果位置不为null，表示有元素，则调用equals方法比较属性值

5. 一样：不存         不一样：存入数组，形成链表

   JDK8以前：新元素存入数组，老元素挂在新元素下面

   JDK8及以后：新元素直接挂在老元素下面

​		JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树

​		如果集合存储的是自定义对象，必须重写hashCode和equals方法

### 单列集合常见的使用场景

1. 如果想要集合中的元素可重复
   用ArrayList集合，基于数组的。（用的最多）

2. 如果想要集合中的元素可重复，而且当前的增删操作明显多于查询
   用LinkedList集合，基于链表

3. 如果想对集合中的元素去重
   用HashSet集合，基于哈希表（用的最多）

4. 如果想要对集合中的元素去重，而且保留存取的顺序
   用LinkHashSet集合，基于哈希表和双链表，效率低于HashSet。

5. 如果想要对集合中的元素进行排序

   用TreeSet集合，基于红黑树。后续也可以用List集合实现排序

## 双列集合（Map）

### 特点

1. 双列集合一次需要存一对数据，分别为键和值
2. 键不可以重复，值可以重复
3. 键和值是一一对应的，每一个键只能找到自己对应的值
4. 键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java总叫做“Entry对象”

### HashMap

1. HashMap底层是哈希表
2. 依赖hashCOde方法和equals方法保障**键的唯一**
3. 如果键存储的是自定义对象，需要重写hashCOde方法和equals方法，如果只是值存储的是自定义对象，则不需要重写

LinkedHashMap

1. 由键决定；有序，不重复，无索引
2. 这里的有序指的是保证存储和取出的元素顺序一致
3. 原理：底层数据结构依然是哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。

### TreeMap

1. TreeMap集合的特点是怎么样的？
   不重复、无索引、可排序
   底层基于红黑树实现排序，增删改查性能都比较好
2. TreeMap集合排序的两种方式？
   1）实现Comparable接口，指定比较规则
   2）创建集合是传递Comparator比较器对象，指定比较规则（一般在Java提供的默认排序规则无法满足时使用）

### Map集合常见的面试问题

1. TreeMap添加元素的时候，键是否重写hashCode和equals方法
   不需要

2. hashMap是哈希表结构的，JDK8开始由数组、链表、红黑树组成，既然有红黑树，那么HashMap的键是否需要实现Comparable接口或者传递比较器对象呢？
   不需要。因为在HashMap底层，默认是使用哈希值的大小来创建红黑树的

3. TreeMap和HashMap谁的效率高？
   如果是最坏的情况，比如添加了8个元素，这8个元素形成了链表，此时TreeMap的效率更高。
   但是这种情况出现的机率很小。一般而言，还是HashMap的效率更高

4. 你觉得在Map集合中，Java会提供一个如果键重复了，不会覆盖的put方法吗？

   有，即putIfAbsent
   （**传递一个思想：代码中的逻辑都有两面性，如果我们只知道其中的A面，而且代码中还发现了又变量可以控制，那么该逻辑一定会存在B面**

     		**习惯：**

   ​	　**boolean类型的变量控制，一般只有AB面，因为Boolean只有两个值。**

   ​		**int类型的变量控制，一般至少有三面，因为int类型可以取多个值。**		

   ）

5. 三种双列集合，以后如何选择？
   三种集合分别为
   HashMap、LinkHashMap、TreeMap
   默认：HashMap（效率最高）
   如果要保证存取有序：LinkHashMap
   如果要进行排序：TreeMap


## 对应思想

1. 如果原始数据的规律非常复杂，我们可以先手动让每一个数据跟唯一的序号产生对应关系。
2. 序号就是数字，规律非常简单，后续的所有操作，我们以序号为准
3. 当真正要操作原始数据的时候，再通过序号找到原始数据即可

## 不可变集合

1. 不可变集合的特点
   定义完成后不可以进行修改、添加或者删除操作
2. 如何创建不可变集合？
   List、Set、Map接口中，都存在of方法可以创建不可变集合
3. 三种方式的细节
   List：直接用
   Set：元素不能重复
   Map：元素不能重复、键值对数量不能超过10个。超过10个用ofEntries方法。JDK版本在10或以上的，可以使用copyOf方法

## Stream流

1. Stream流的作用
   结合了Lambda表达式，简化集合、数组的操作
2. Stream的使用步骤
   获取Stream流对象
   使用中间方法处理数据
   使用终结方法处理数据
3. 如何获取Stream流对象
   单列集合：Collection中的默认方法stream
   双列集合：不能直接获取
   数组：Arrays工具类中的静态方法stream
   一堆零散的数据：Stream接口中的静态方法of
4. 常见方法
   中间方法：filter、limit、skip、distinct、concat、map（类型转换）
   终结方法：forEach、count、collect

## 方法引用

方法引用就是把已经有的方法拿过来用，当作函数式接口中的抽象方法体

### 作用

1. 让匿名内部类可以像普通方法一样方便引用
2. 可以根据需求，不同的接口定义不同的方法，方便后续维护

### 引用条件

1. 引用处必须是函数式接口
2. 被引用的方法必须已经存在
3. 被引用方法的形参和返回值需要和抽象方法保持一致
4. 被引用方法的功能要满足当前需求

## 异常

![image-20240302105835486](image\image-20240302105835486.png)

Exception:叫做异常，代表程序可能出现的问题
				   我们通常会用Exception以及它的子类来封装程序出现的问题

运行时异常：RuntimeException及其子类，编译阶段不会出现异常提醒。
					   运行时出现的异常（如：数组索引越界异常）

编译时异常：编译阶段就会出现异常提醒。（如：日期解析异常）

### 作用

1.异常是用来查询bug的关键参考信息

2.异常可以作为方法内部的一种特殊的返回值，以便通知调用者底层的执行情况

### 异常的处理方式

#### JVM默认处理方式

1. 把异常的名称，异常原因及异常的位置等信息输出在控制台
2. 程序停止执行，异常下面的代码不会再执行

#### 自己处理（捕获异常）

​	格式：

​	try{

 肯出现的异常

}catch（异常类名 变量名 ）{

​	处理异常的代码

}

## File

1. File表示什么？
   Fil对象表示路径，可以是文件，也可以是文件夹
   这个路径可以是存在的，也可以是不存在的

2. 绝对路径和相对路径是什么意思？
   绝对路径是带盘符
   相对路径是不带盘符的，默认到当前项目下去找

   File的三种构造方法

3. ```java
   public File(String name)                    根据文件路径创建文件对象
   public File(String name ,String child)      把父级路径和子级路径进行拼接
   public File(File parent ,String child)      把父级路径和子级路径进行拼接
   ```

## IO流

1. 什么是IO流？
   存储和读取数据的解决方案
   I：input   		O：output
   流：向水流一样传输数据
2. IO流的作用？
   用于读写数据（本地文件，网络文件）
3. IO流按照流向分可以分为哪两种流？
   输出流：程序   ---写入到----> 文件
   输出流：文件   ---读取到----> 程序
4. IO流按照操作文件的类型可以分类为哪两种流？
   字节流：可以操作所有类型的文件
   字符流：只能操作纯文本文件
5. 什么是纯文本文件？
   用windows系统自带的记事本打开并且能读懂的文件
   如：txt、md、xml，lrc等

### FileOutputStream书写细节

1. 创建字节输出流对象
   细节1：参数是字符串表示路径或者file对象都是可以的
   细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的
   细节3：如果文件已经存在，会清空原文件
2. 写数据
   细节：write方法的参数是整数，但是实际上写到本地文件中的是ASCII上对应的字符
3. 释放资源
   细节：每次使用完流之后都有释放资源

### FileInPutStream书写细节

1. 创建字节输入流对象
   细节1：如果对象不存在，直接报错
2. 读取数据
   细节1：一次度一个字节，读出来的是数据在ASCII码上对应的数字
   细节2：读到文件末尾时，read方法返回-1
3. 释放资源
   细节1：每次使用完流必须要释放资源

## 字符集

### GBK

1. 在计算机中任意数据都是以二进制的形式来存储的
2. 计算机中最小的存储单元是一个字节
3. ASCII字符集中，一个英文占一个字节
4. 简体中文版Windows，默认使用GBK字符集
5. GBK字符集完全兼容ASCII字符集
   一个英文占一个字节，二进制第一位是
   一个中文站两个字节，二进制高位字节的第一位是1

### Unicode

1. Unicode字符集的UTF-8编码格式
   一个英文占一个字节，二进制第一位是0，转成十进制是正数
   一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数

### 字符流原理解析

1. 创建字符输入流对象
   底层：关联文件，并创建缓冲区（长度为8192的字节数组）
2. 读取数据
   底层：1.判断缓冲区中是否有数据可以读取
               2.缓冲区没有数据：从文件中获取数据，撞装到缓冲区中，每次尽可能装满缓冲区
                 如果文件中也没有数据了，返回 -1
               3.缓冲区有数据： 就冲缓冲区中读取
   空参的read方法：一次读取一个字节，遇到中文一次读取多个字节，把字节解码并转换成十进制返回
   有参的read方法：把读取数据，解码，强转三步合并了，并将强转之后的字符放到数组中

### 缓冲流（高级流）

1. 缓冲流有几种？
   字节缓冲输入流：BufferedInputStream
   字节缓冲输出流：BufferedOutputStream
   字符缓冲输入流：BufferedReader
   字符缓冲输出流：BufferedWriter
2. 缓冲流为什么可以提高性能？
   缓冲流自带长度为8192的缓冲区
   可以显著提高字节流的读写性能
   对于字符流提升不明显，对于字符缓冲流而言关键点是两个特有的方法
3. 字符缓冲流两个特有的方法是什么？
   字符缓冲输入流BufferedReader:readline()
   （一次读一行，但是不会把换行符读进去）
   字符缓冲输出流BufferedWriter: newLine()
   （仅该流能用的可以写入换行符的方法，且各系统通用）

### 序列化流\对象操作输出流

可以将Java中的对象写到文件中

### 反序列化流\对象操作输入流

可以将对象输入到程序中

### 序列化流/反序列化流的细节汇总

1. 使用序列化流将对象写到文件中时，需要让Javabean类实现serializable接口，否则，会出现NotSerializableException异常
2. 序列化流写到文件中的数不能修改，一旦修改就无法再次都回来了
3. 序列化对象后，修改了Javabean类，再次反序列化，会抛出InvalidClassException异常
   解决方案：给Javabean类添加serialVersionUID(版本号、序列号)
4. 如果一个对象中的某个成员变量的值不想被序列化，该如何实现？
   解决方案：该该成员变量加transient关键字修饰，该关键标记的成员变量不参与序列化过程

### 打印流

打印流有几种？各有什么特点？

有字节打印流和字符打印流两种
打印流不操作数据源，只能操作目的地
字节打印流：默认自动刷新（缓冲区），特有的println自动换行
字符打印流：自动刷新需要手动开启，特有的println自动换行

### properties集合

properties是map集合的一种，可以存储任意类型的数据，它的特有方法store，和write可以操作文件中的数据，配合.properties文件进行使用

## 多线程

1. 什么是多线程？
   线程是计算机可以调度的最小单位，包含在进程当中。一个运行中的软件可以看作是一个进程，进程中包含若干线程。
   线程是应用软件中相互独立，可以同时运行的功能。
2. 多线程的作用
   提高效率
3. 多线程的应用场景
   只要你想让多个事情同时运行就需要用到多线程
   比如：软件中的耗时操作、所有的聊天软件、所有的服务器

### 并发和并行

1. 并发：在同一时刻，有多个指令在单个CPU上交替执行
2. 并行：在同一时刻，有多个指令在多个CPU上同时执行

### Thread常用的方法

```java
/*
String getName()                            返回此线程的名称
void setName(String)                        设置线程的名字（默认Thread-1,2,3,4... ）

static Thread currentThread()               获取当前线程的对象（我们每次运行代码时，都是运行在JVM默认的main线程中）
static void sleep(long time)                让线程休眠指定时间，单位为毫秒
setPriority(int newPriority)                设置线程的优先级（最小为1，最大为10，默认为5）
final int getPriority()                     获取线程的优先级（抢到CPU的概率大小）
final int setDaemon(boolean on)             设置为守护线程（当其他非守护线程执行完毕之后，守护线程会陆续结束（可能不会执行完整代码））
public static void yield()                  出让线程\礼让线程（让出当前CPU的执行权）
public static void join()                   插入线程\插队线程
*/
```

### 线程的生命周期

![image-20240324213932551](image\image-20240324213932551.png)

### 同步代码块

```java
//同步代码块
//方法一
synchronized (obj){
    ...
}

//方法二
try{
    lock();
    ...
}catch(){
    ...
}finaly{
   unlock(); 
}
```



### 同步方法

用synchronized去修饰，静态方法的锁对象默认为Thread.Class（该类的字节码文件），非静态则是this

### 线程的状态

新建（NEW） 			 				----------------------->		创建线程对象

就绪（RUNNABLE） 				 ----------------------->		start方法

阻塞（BLOCKED）					 ----------------------->		无法获得锁对象

等待（WAITING）	  				----------------------->		wait方法

计时等待（TIME_WAITING）    -----------------------> 	  sleep方法

结束（TERMINATED）			  ----------------------->		全部代码运行完毕

PS：实际定义中线程并没有运行状态，因为jvm不负责线程的执行

### 线程池（Executors）

1. 创建一个池子。池子中是空的
2. 提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给线程池，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可
3. 但是如果提交任务时，池子里没有空闲线程，也无法创建新的线程，任务就会排队等待

#### 自定义线程池

![image-20240406143912608](image\image-20240406143912608.png)

#### 线程池的工作原理

创建一个空的池子，有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程

不断提交任务，会有以下三个临界点：

1. 当核心线程满时，再提交任务就会排队
2. 当核心线程满，队伍满时，会创建临时线程
3. 当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略（内部类）

#### 线程池的大小

![image-20240406145227516](image\image-20240406145227516.png)

Thread dump是一个工具，可以用来获取CPU计算时间和等待时间

## 网络编程

1. 什么是网络编程？
   计算机和计算机治安通过网络进行数据传输
2. 常见的软件架构有哪些？
   CS/BS
3. 通信软件架构CS/BS各有什么区别和优缺点？
   CS：客户端服务端模式需要开发客户端
   BS：浏览器模式不需要开发客户端
   CS：适合定制专业化的软件如：IDEA、网游
   BS：适合移动互联网应用，可以再任何地方随时访问系统

### 网络编程三要素

1. 网络编程三要素分别是什么？
   IP、端口号、协议
2. 网络编程三要素分别表示什么？
   IP：设备再网络中的地址、是唯一标识
   端口号：应用程序在设备中的唯一标识
   协议：数据在网络中传输的规则，常见的协议又UDP、TCP、http、https、ftp

#### IP

1. IP的作用
   设备在网络中的地址，是唯一标识
2. IPv4有什么特点
   目前的主流方案
   最多只有2^32次方个IP，目前已经用完了
3. IPv6有什么特点
   为了解决IPv4不够用而出现的
   最多有2^128次方个IP
   可以为地球上的每一粒仨沙子都设定ip

#### IPv4

1. 现在是如何解决IPv4不够的问题？
   利用局域网IP解决IP不够的问题（多台主机共用一个IP）
2. 特殊的IP
   127.0.0.1（永远标识本机）
3. 常见的两个CMD命令
   ipconfig：查看本机IP地址
   ping：检查网络是否连接

#### 端口号

应用程序在设备中的唯一标识。
端口号：有两个字节表示的整数，取值：0~65535
 				其中0~1023之间的端口号用于一些知名的网络服务或者应用
				 我们自己使用1024以上的端口号就可以了
注意：一个端口号只能被一个应用程序使用

#### 协议

计算机网络中，连接和通信的规则被称为网络通信协议

1. UDP协议
   用户数据报协议（User Datagram Protocol）
   UDP是面向无连接的通信协议
   速度快，有大小限制，一次最多发送64k，数据不安全，易丢失数据
2. TCP协议 
   传输控制协议TCP（Transmission Control Protocol）
   TCP协议是面向连接的通信协议
   速度慢、没有大小限制，数据安全

#### UDP的三种通信方式

1. 单播
   一开始练习的代码都是单播
2. 组播
   组播地址：224.0.0.0~239.255.255.255
           其中224.0.0.0~224.0.0.255为预留的组播地址
3. 广播
   广播地址：255.255.255.255

#### TCP通信程序



1. 三次握手
   ![image-20240409232517915](image\image-20240409232517915.png)
2. 四次挥手
   ![image-20240409232638499](image\image-20240409232638499.png)

## 反射

什么是反射？
        反射允许对成员变量、成员方法和构造方法等信息进行编程访问

### 利用反射获取构造方法

![image-20240410221821303](image\image-20240410221821303.png)

```java
public int modifiers()							//获取权限修饰符，以整数形式返回
Parameter[] parameters = T.getParameters()		//（T表示构造方法）获取构造方法的每一个参数
setAccessible()									//临时取消构造方法的访问权限
```

### 利用反射获取成员变量

应用：可以用获取到的Filed对象进行get或set操作，来查看或改变变量记录的值

![image-20240410222936631](image\image-20240410222936631.png)

### 利用反射获取成员方法

![image-20240410223934544](image\image-20240410223934544.png)

### 总结

1. 反射的作用
   获取任意一个类的所有信息
   结合配置文件动态的创建对象
2. 获得class字节码文件对象的三种形式
   Class.forName("全类名");
   类名.class;
   对象.getClass();
3. 如何 获取构造方法、成员方法、成员变量
   get：获取                                           set：设置
   Constructor：构造方法                   Parameter：参数
   Field：成员变量                                Modifiers：修饰符
   Method：方法                                  Declared：已声明的（用于获取限制权限的信息）

## 动态代理

### 程序为什么需要代理？代理长什么样？

​		对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。
​		对象有什么方法想被代理，代理就一定要有对应的方法。

### 动态代理的概念

1. 为什么需要代理？
   代理可以无侵入的给对象增强其他功能
   ![image-20240411223305939](image\image-20240411223305939.png)
2. 代理长什么样？
   代理里面就是对象要被代理的方法
3. Java通过什么来保证代理的方法一致？
   通过接口保证，后面的对象和代理需要实现同一个接口，接口中就是被代理的所有方法

## 完整的Java学习路线

![image-20240411231425664](image\image-20240411231425664.png)
